(* A handwritten Why3 input for a token contract. *)

module UInt256
	use import mach.int.Unsigned
	type uint256
	constant max_uint256: int = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	clone export mach.int.Unsigned with
		type t = uint256,
		constant max = max_uint256
end

module Address
	use import mach.int.Unsigned
	type address
	constant max_address: int = 0xffffffffffffffffffffffffffffffffffffffff (* 160 bit = 40 f's *)
	clone export mach.int.Unsigned with
		type t = address,
		constant max = max_address
end

module BalanceSum
	use import array.Array
	use import UInt256

	function lookup (array uint256) int : int
	axiom lookup_get :
		forall a idx.
			lookup a idx = to_int (Array.get a idx)

	clone export sum.Sum with
		type container = array uint256,
		function f = lookup
end

module BalanceSumTheory
	use import UInt256
	use import array.Array
	use import BalanceSum

	lemma ltle_eq :
		forall x y.
  			x < y + 1 -> y <= x -> y = x

    lemma sum_end_no_change : forall usorig usidx usnew_val.
		BalanceSum.sum
			(Array.set usorig usidx usnew_val) 0 usidx =
		BalanceSum.sum usorig 0 usidx

	axiom lookup_set_different :
		forall usorig usidx usnew_val x.
			usidx < x ->
			lookup (set usorig usidx usnew_val) x = lookup usorig x

	(* TODO: turn this into a lemma *)
	(* This lemma is useful in Coq to prove balanceSubCoq0 *)
	lemma balanceSubCoq0S :
		forall x : int.
			0 <= x ->
			(forall usorig usidx usval usnew_val.
				to_int usnew_val = (to_int (Array.get usorig usidx) - to_int usval) ->
				0 <= usidx < x ->
				sum (set usorig usidx usnew_val) 0 x = (BalanceSum.sum usorig 0 x - to_int usval)) ->
			forall usorig usidx usval usnew_val.
				to_int usnew_val = to_int (Array.get usorig usidx) - to_int usval ->
				0 <= usidx < x + 1 ->
				sum (Array.set usorig usidx usnew_val) 0 (x + 1) =
				sum usorig 0 (x + 1) - to_int usval

	lemma balanceSubCoq00 :
			forall _orig _idx _val _new_val.
				to_int _new_val = to_int (Array.get _orig _idx) - to_int _val ->
				0 <= _idx < 0 ->
				BalanceSum.sum (Array.set _orig _idx _new_val) 0 0 = BalanceSum.sum _orig 0 0 - to_int _val

	(* This lemma is slightly easier to prove in Coq than [balanceSub], I think. *)
	lemma balanceSubCoq0 :
		forall _lim.
			0 <= _lim ->
			forall _orig _idx _val _new_val.
				to_int _new_val = to_int (Array.get _orig _idx) - to_int _val ->
				0 <= _idx < _lim ->
				BalanceSum.sum (Array.set _orig _idx _new_val) 0 _lim = BalanceSum.sum _orig 0 _lim - to_int _val

	(* CVC4 can deduce this from [balanceSubCoq0] *)
	lemma balanceSub :
		forall _lim _orig _idx _val _new_val.
			to_int _new_val = to_int (Array.get _orig _idx) - to_int _val ->
			0 <= _idx < _lim ->
			BalanceSum.sum (Array.set _orig _idx _new_val) 0 _lim = BalanceSum.sum _orig 0 _lim - to_int _val

	(* TODO: turn this into a lemma *)
	axiom balanceAdd :
		forall _lim _orig _idx _val _new_val.
			to_int _new_val = to_int (Array.get _orig _idx) + to_int _val ->
			0 <= _idx < _lim ->
			BalanceSum.sum (Array.set _orig _idx _new_val) 0 _lim = BalanceSum.sum _orig 0 _lim + to_int _val

	(* TODO: turn this into a lemma *)
	axiom small_elements :
		forall _array _idx _lim.
			0 <= _idx <= _lim ->
			to_int _array[_idx] <= BalanceSum.sum _array 0 (_lim + 1)
end

module TokenContract (* or a theory? *)

	use Address
	use BalanceSum
	use import UInt256
	use import array.Array
	use import BalanceSumTheory

	exception Revert

	constant total : int
	axiom total_small : total <= max_uint256

	let transfer (_from : Address.address) (_to : Address.address) (_val : uint256) (_orig : array uint256) : array uint256

		requires { _orig.length = Address.max_address + 1 }
		ensures  { _orig.length = Address.max_address + 1 }

		requires { BalanceSum.sum _orig 0 (Address.max_address + 1) = total }
		ensures { BalanceSum.sum _orig 0 (Address.max_address + 1) = total }

	=
		let backup = _orig in
		try
			if _orig[Address.to_int _from] < _val then raise Revert else
			_orig[Address.to_int _from] <- _orig[Address.to_int _from] - _val;
			assert { BalanceSum.sum _orig 0 (Address.max_address + 1) = total - to_int _val };
			assert { 0 <= Address.to_int _to };
			assert { Address.to_int _to <= Address.max_address };
			assert { to_int _orig[Address.to_int _to] <= BalanceSum.sum _orig 0 (Address.max_address + 1) };
			_orig[Address.to_int _to] <- _orig[Address.to_int _to] + _val;
			_orig
		with
			Revert -> backup
		end
end
