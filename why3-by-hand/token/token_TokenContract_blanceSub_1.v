(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.

(* Why3 assumption *)
Definition unit := unit.

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter max: Z.

Parameter to_int: t -> Z.

(* Why3 assumption *)
Definition in_bounds (n:Z): Prop := (0%Z <= n)%Z /\ (n <= max)%Z.

Axiom to_int_in_bounds : forall (n:t), (in_bounds (to_int n)).

Axiom extensionality : forall (x:t) (y:t), ((to_int x) = (to_int y)) ->
  (x = y).

Parameter zero_unsigned: t.

Axiom zero_unsigned_is_zero : ((to_int zero_unsigned) = 0%Z).

Axiom address : Type.
Parameter address_WhyType : WhyType address.
Existing Instance address_WhyType.

Parameter to_int1: address -> Z.

(* Why3 assumption *)
Definition in_bounds1 (n:Z): Prop := (0%Z <= n)%Z /\
  (n <= 1461501637330902918203684832716283019655932542975%Z)%Z.

Axiom to_int_in_bounds1 : forall (n:address), (in_bounds1 (to_int1 n)).

Axiom extensionality1 : forall (x:address) (y:address),
  ((to_int1 x) = (to_int1 y)) -> (x = y).

Parameter zero_unsigned1: address.

Axiom zero_unsigned_is_zero1 : ((to_int1 zero_unsigned1) = 0%Z).

(* Why3 assumption *)
Inductive array (a:Type) :=
  | mk_array : Z -> (map.Map.map Z a) -> array a.
Axiom array_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.
Implicit Arguments mk_array [[a]].

(* Why3 assumption *)
Definition elts {a:Type} {a_WT:WhyType a} (v:(array a)): (map.Map.map Z a) :=
  match v with
  | (mk_array x x1) => x1
  end.

(* Why3 assumption *)
Definition length {a:Type} {a_WT:WhyType a} (v:(array a)): Z :=
  match v with
  | (mk_array x x1) => x
  end.

(* Why3 assumption *)
Definition get {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z): a :=
  (map.Map.get (elts a1) i).

(* Why3 assumption *)
Definition set {a:Type} {a_WT:WhyType a} (a1:(array a)) (i:Z) (v:a): (array
  a) := (mk_array (length a1) (map.Map.set (elts a1) i v)).

Axiom uint256 : Type.
Parameter uint256_WhyType : WhyType uint256.
Existing Instance uint256_WhyType.

Parameter to_int2: uint256 -> Z.

(* Why3 assumption *)
Definition in_bounds2 (n:Z): Prop := (0%Z <= n)%Z /\
  (n <= 115792089237316195423570985008687907853269984665640564039457584007913129639935%Z)%Z.

Axiom to_int_in_bounds2 : forall (n:uint256), (in_bounds2 (to_int2 n)).

Axiom extensionality2 : forall (x:uint256) (y:uint256),
  ((to_int2 x) = (to_int2 y)) -> (x = y).

Parameter zero_unsigned2: uint256.

Axiom zero_unsigned_is_zero2 : ((to_int2 zero_unsigned2) = 0%Z).

Parameter lookup: (array uint256) -> Z -> Z.

Parameter sum: (array uint256) -> Z -> Z -> Z.

Axiom Sum_def_empty : forall (c:(array uint256)) (i:Z) (j:Z), (j <= i)%Z ->
  ((sum c i j) = 0%Z).

Axiom Sum_def_non_empty : forall (c:(array uint256)) (i:Z) (j:Z),
  (i < j)%Z -> ((sum c i j) = ((lookup c i) + (sum c (i + 1%Z)%Z j))%Z).

Axiom Sum_right_extension : forall (c:(array uint256)) (i:Z) (j:Z),
  (i < j)%Z -> ((sum c i j) = ((sum c i (j - 1%Z)%Z) + (lookup c
  (j - 1%Z)%Z))%Z).

Axiom Sum_transitivity : forall (c:(array uint256)) (i:Z) (k:Z) (j:Z),
  ((i <= k)%Z /\ (k <= j)%Z) -> ((sum c i j) = ((sum c i k) + (sum c k
  j))%Z).

Axiom Sum_eq : forall (c1:(array uint256)) (c2:(array uint256)) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((lookup c1 k) = (lookup c2
  k))) -> ((sum c1 i j) = (sum c2 i j)).

(* Why3 goal *)
Theorem blanceSub : forall (uslim:Z) (usorig:(array uint256)) (usidx:Z)
  (usval:uint256) (usnew_val:uint256),
  ((to_int2 usnew_val) = ((to_int2 (get usorig
  usidx)) - (to_int2 usval))%Z) -> (((0%Z <= usidx)%Z /\
  (usidx < uslim)%Z) -> ((sum (set usorig usidx usnew_val) 0%Z
  uslim) = ((sum usorig 0%Z uslim) - (to_int2 usval))%Z)).
(* Why3 intros uslim usorig usidx usval usnew_val h1 (h2,h3). *)
Proof.
  intro uslim.
  case uslim.
  { (* zero *)
    intros ? idx ? ? _.
    omega.
  }
  {
    (* positive *)
    clear uslim.
    induction p using Pos.peano_ind.
    {
      intros orig idx val new_val H.
      intro idx0.
      rewrite Sum_right_extension by (compute; auto).
      simpl.
      Search _ sum.
      rewrite Sum_def_empty by (compute; congruence).
      rewrite Sum_right_extension by (compute; auto).
      simpl.
      rewrite Sum_def_empty by (compute; congruence).
      admit.
    }
    { (* the induction *)
      admit.
    }
  }
  { (* negative *)
    intros ? ? idx ? ? _.
    intro H.
    case H as [H0 H1].
    generalize (Z.le_lt_trans _ _ _ H0 H1).
    set (P := (0 < Z.neg _)%Z).
    compute in P.
    congruence.
  }
Admitted.

